name: Update with requested PRs
on:
  workflow_dispatch:
  schedule: # run Tuesdays and Wednesdays at 12:00
    - cron: '0 12 * * 2'
    - cron: '0 12 * * 3'
jobs:
  pr-requests:
    runs-on: ubuntu-latest
    if: github.repository == 'AliceO2Group/dpg-documentation'
    steps:

      - name: Checkout documentation
        uses: actions/checkout@v4
        with:
          repository: AliceO2Group/dpg-documentation
          path: dpg-documentation
          persist-credentials: false
          # To push the updated branch, we need a non-shallow clone.
          fetch-depth: 0

      - name: Create PR branch in docs
        working-directory: dpg-documentation
        run: |
          git config --global user.email 'alibuild@cern.ch'
          git config --global user.name 'ALICE Action Bot'
          # Overwrite branch, creating a new one based on HEAD
          git checkout -B auto-update-requests

      - name: Get PRs
        id: get_prs
        uses: octokit/graphql-action@v2.x
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          query: |
            query {
              doc: repository(owner: "AliceO2Group", name: "dpg-documentation") {
                id
              }
              AliceO2: repository(owner: "AliceO2Group", name: "AliceO2") {
                pullRequests(first: 100, states: [MERGED, OPEN], orderBy: { field: UPDATED_AT, direction: DESC }) {
                  nodes {
                    title
                    createdAt
                    updatedAt
                    mergedAt
                    number
                    labels(first:10) {
                      edges{
                        node {
                          name
                        }
                      }
                    }
                    state
                    url
                    author {
                      login
                    }
                    mergeCommit {
                      oid
                    }
                    commits {
                      nodes {
                        commit {
                          oid
                        }
                      }
                    }
                  }
                }
              }
              O2DPG: repository(owner: "AliceO2Group", name: "O2DPG") {
                pullRequests(first: 100, states: [MERGED, OPEN], orderBy: { field: UPDATED_AT, direction: DESC }) {
                  nodes {
                    title
                    createdAt
                    updatedAt
                    mergedAt
                    number
                    labels(first:10) {
                      edges{
                        node {
                          name
                        }
                      }
                    }
                    state
                    url
                    author {
                      login
                    }
                    mergeCommit {
                      oid
                    }
                    commits {
                      nodes {
                        commit {
                          oid
                        }
                      }
                    }
                  }
                }
              }
              QualityControl: repository(owner: "AliceO2Group", name: "QualityControl") {
                pullRequests(first: 100, states: [MERGED, OPEN], orderBy: { field: UPDATED_AT, direction: DESC }) {
                  nodes {
                    title
                    createdAt
                    updatedAt
                    mergedAt
                    number
                    labels(first:10) {
                      edges{
                        node {
                          name
                        }
                      }
                    }
                    state
                    url
                    author {
                      login
                    }
                    mergeCommit {
                      oid
                    }
                    commits {
                      nodes {
                        commit {
                          oid
                        }
                      }
                    }
                  }
                }
              }
            }

      - name: Store PRs
        run: |
          cat <<\EOF > prs.json
          ${{ steps.get_prs.outputs.data }}
          EOF
          cat prs.json

      - name: Make the request pages
        shell: python
        run: |
          import json

          def get_prs(prs):
              # Need to sort by
              # - MERGED or OPEN
              #   - async-labels
              #     - mergedAt or updatedAt
              prs_dict = {}

              pr_numbers = []

              for pr in prs:

                  number = pr['number']

                  if number in pr_numbers:
                      continue

                  pr_numbers.append(number)

                  flag = pr['state']

                  if flag not in prs_dict:
                      prs_dict[flag] = {}

                  label_edges = pr.get('labels', {}).get('edges', None)
                  if not label_edges:
                      continue

                  label_names = []
                  for edge in label_edges:
                      label_name = edge.get('node', {}).get('name', None)
                      if not label_name:
                          continue
                      if not label_name.startswith('async-'):
                          continue
                      label_names.append(label_name)

                  for label_name in label_names:

                      if label_name.endswith('-accepted'):
                          # only go ahead if not yet accepted
                          continue

                      # check if the accepted label is already there
                      accepted_label_name = f'{label_name}-accepted'
                      if accepted_label_name in label_names:
                          continue

                      if label_name not in prs_dict[flag]:
                          prs_dict[flag][label_name] = []

                      prs_dict[flag][label_name].append(pr)

              return prs_dict


          def make_report(prs, repo_name, outfile):
              prs = prs.get('pullRequests', {}).get('nodes', None)
              if not prs:
                  # nothing found
                  return

              prs_dict = get_prs(prs)

              with open(outfile, 'w') as f:

                  f.write(f'# List PRs for {repo_name} (from oldest to recent)\n')

                  # first put the merged PRs
                  for state, prs_per_label in prs_dict.items():

                      f.write(f'\n\n## PRs in state {state}')

                      for label_name, pr_list in prs_per_label.items():

                          f.write(f'\n\n### For label {label_name}\n\n')

                          sort_by = [pr['mergedAt'] for pr in pr_list]
                          common_header = '| Author | Package | PR | PR title | State | Merged at |\n| --- | --- | --- | --- | --- | --- |\n'

                          if None in sort_by:
                              sort_by = [pr['updatedAt'] for pr in pr_list]
                              common_header = '| Author | Package | PR | PR title | State | Updated at |\n| --- | --- | --- | --- | --- | --- |\n'

                          f.write(common_header)

                          for s, pr in sorted(zip(sort_by, pr_list)):
                              f.write(f'| {pr["author"]["login"]} | {repo_name} | [PR]({pr["url"]}) | {pr["title"]} | {state} | {s} |\n')

          def make_markdowns(prs_json):
              prs = None
              with open(prs_json, 'r') as f:
                  prs = json.load(f)

              for repo_name, prs_repo in prs.items():
                  if repo_name not in ['AliceO2', 'O2DPG', 'QualityControl']:
                      continue
                  make_report(prs_repo, repo_name, f'dpg_pr_report_{repo_name}.md')

          make_markdowns('prs.json')


      - name: Add and push changes, get repo ID
        id: add_push_repo_id
        env:
          GITHUB_TOKEN: ${{ secrets.ALIBUILD_GITHUB_TOKEN }}
        working-directory: dpg-documentation/
        run: |
          cp ../*.md docs/software/requests_automatic
          echo "NEED_PR=true" >> $GITHUB_OUTPUT
          if git diff --quiet; then
            echo "No changes, nothing to push."
            echo "NEED_PR=false" >> $GITHUB_OUTPUT
            exit 0 # Nothing has changed, so no need to send a PR.
          fi
          # Add the markdown files here
          git add *.md
          git commit -m 'Automatic update of PR requests'
          git remote set-url origin "https://alibuild:$GITHUB_TOKEN@github.com/AliceO2Group/dpg-documentation"
          git push -f origin auto-update-requests
          repo_id=$(jq -r '.doc.id' ../prs.json)
          echo "REPO_ID=${repo_id}" >> $GITHUB_OUTPUT

      - name: Open PR
        id: open_pr
        if: ${{ steps.add_push_repo_id.outputs.NEED_PR == 'true' }}
        uses: octokit/graphql-action@v2.x
        env:
          GITHUB_TOKEN: ${{ secrets.ALIBUILD_GITHUB_TOKEN }}
          repo_id: ${{ github.repository_id }}
        with:
          query: |
            mutation CreatePullRequest($repoId: ID!) {
              createPullRequest(input: {
                repositoryId: $repoId,
                baseRefName: "main",
                headRefName: "auto-update-requests",
                title: "Update requests",
                body: ""
              }) {
                pullRequest {
                  number
                  url
                }
              }
            }
          variables: |
            {
              "repoId": "${{ steps.add_push_repo_id.outputs.REPO_ID }}"
            }
